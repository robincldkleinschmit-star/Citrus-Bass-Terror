import { Injectable } from '@angular/core';
import { GoogleGenAI } from "@google/genai";
import JSZip from 'jszip';

@Injectable({
  providedIn: 'root'
})
export class VstGeneratorService {
  private ai: GoogleGenAI;

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env['API_KEY'] || '' });
  }

  async generateVstBundle(params: {
    gain: number,
    drive: number,
    bass: number,
    mid: number,
    treble: number,
    compressorBlend: number,
    compressorSustain: number
  }): Promise<Blob> {
    
    // 1. DSP Prompt
    const processorPrompt = `
      You are an expert Audio DSP Engineer specializing in C++ and the JUCE Framework.
      Create a production-ready 'PluginProcessor.cpp' file for a VST3 plugin.
      
      The DSP chain must mimic this exact signal path:
      1. Input Pad (-6dB if active)
      2. Optical Compressor (Threshold variable via Sustain ${params.compressorSustain}/10, Ratio 6:1, Attack 20ms, Release 200ms).
      3. Compressor Blend (Wet/Dry mix: ${params.compressorBlend}/10).
      4. Tube Preamp Stage (Asymmetric WaveShaper distortion, Drive level: ${params.drive}/10).
      5. Tone Stack:
         - Bass (Low Shelf 100Hz, Gain: ${params.bass}/10)
         - Mid (Peaking 400Hz, Gain: ${params.mid}/10)
         - Treble (High Shelf 2500Hz, Gain: ${params.treble}/10)
      6. Convolution Cabinet Simulator (Placeholder for 4x10 IR loading).
      
      Current Snapshot Values to bake into defaults:
      - Input Gain: ${params.gain}
      
      Output ONLY the raw C++ code for the PluginProcessor.cpp file.
    `;

    // 2. UI Prompt
    const editorPrompt = `
      You are an expert UI/UX Engineer for Audio Plugins using JUCE.
      Create a 'PluginEditor.cpp' file using the JUCE 'Graphics' class.
      
      Design Requirements:
      - Background: Baby Blue (#89CFF0) with a subtle leather/noise pattern.
      - Component Layout:
        - Left: Input Switch, Gain Knob, Drive Knob.
        - Center: Bass, Mid, Treble Knobs.
        - Right: Volume Knob, Power Switch, Blue Jewel Light (glowing effect).
      - Graphics: Use vector graphics (Path, fillPath, strokePath) to draw realistic knobs with shadows and indicators.
      - Branding: Draw the text "CITRUS" in a handwritten marker font style at the bottom.
      
      Output ONLY the raw C++ code for the PluginEditor.cpp file. Assume standard JUCE boilerplates are in the header.
    `;

    try {
      // Execute both requests in parallel
      const [processorRes, editorRes] = await Promise.all([
        this.ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: processorPrompt
        }),
        this.ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: editorPrompt
        })
      ]);

      const processorCode = processorRes.text || '// Error generating Processor code';
      const editorCode = editorRes.text || '// Error generating Editor code';
      const readme = `
# Citrus Terror Bass - VST3 Source Code
Generated by AI

## Instructions
1. Create a new JUCE Audio Plugin project (Projucer).
2. Replace 'PluginProcessor.cpp' and 'PluginEditor.cpp' with the files in this zip.
3. Ensure you add the necessary member variables to your Header (.h) files matching the variables used in the .cpp files (e.g., audio parameters, slider attachments).
4. Compile for VST3/AU/AAX.

## Current Settings Snapshot
- Gain: ${params.gain}
- Drive: ${params.drive}
- EQ: B:${params.bass} M:${params.mid} T:${params.treble}
      `;

      // Zip the files
      const zip = new JSZip();
      zip.file("PluginProcessor.cpp", processorCode);
      zip.file("PluginEditor.cpp", editorCode);
      zip.file("README.txt", readme);

      return await zip.generateAsync({ type: "blob" });

    } catch (e) {
      console.error('AI Generation failed', e);
      throw new Error('Failed to generate VST bundle.');
    }
  }
}